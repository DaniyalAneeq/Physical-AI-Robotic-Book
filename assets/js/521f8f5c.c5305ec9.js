"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[117],{6770:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>r,contentTitle:()=>t,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module2/chapter2-gazebo-physics","title":"Advanced Simulation in Gazebo: Physics and Environments","description":"Learning Objectives","source":"@site/docs/module2/chapter2-gazebo-physics.md","sourceDirName":"module2","slug":"/module2/chapter2-gazebo-physics","permalink":"/Physical-AI-Robotic-Book/docs/module2/chapter2-gazebo-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/DaniyalAneeq/Physical-AI-Robotic-Book/tree/main/AIdd-book/docs/module2/chapter2-gazebo-physics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"id":"chapter2-gazebo-physics","title":"Advanced Simulation in Gazebo: Physics and Environments","sidebar_position":2},"sidebar":"bookSidebar","previous":{"title":"Introduction to Digital Twins: Gazebo & Unity","permalink":"/Physical-AI-Robotic-Book/docs/module2/chapter1-intro-digital-twins"},"next":{"title":"Environment Building in Unity: Scenes and Robots","permalink":"/Physical-AI-Robotic-Book/docs/module2/chapter3-unity-environments"}}');var s=i(4848),l=i(8453);const a={id:"chapter2-gazebo-physics",title:"Advanced Simulation in Gazebo: Physics and Environments",sidebar_position:2},t=void 0,r={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Deep Theoretical Explanation",id:"deep-theoretical-explanation",level:2},{value:"The <code>&lt;collision&gt;</code> and <code>&lt;visual&gt;</code> Distinction",id:"the-collision-and-visual-distinction",level:3},{value:"Modeling Friction",id:"modeling-friction",level:3},{value:"Practical Tasks",id:"practical-tasks",level:2},{value:"1. Create a Gazebo Package",id:"1-create-a-gazebo-package",level:3},{value:"2. Create <code>worlds</code>, <code>models</code>, and <code>launch</code> directories",id:"2-create-worlds-models-and-launch-directories",level:3},{value:"3. Create the World and Robot SDF files",id:"3-create-the-world-and-robot-sdf-files",level:3},{value:"4. Create the Launch File",id:"4-create-the-launch-file",level:3},{value:"5. Build and Launch",id:"5-build-and-launch",level:3},{value:"Diagrams",id:"diagrams",level:2},{value:"Code Templates",id:"code-templates",level:2},{value:"Detailed Robot SDF with Friction",id:"detailed-robot-sdf-with-friction",level:3},{value:"World SDF with Custom Physics",id:"world-sdf-with-custom-physics",level:3},{value:"ROS 2 Launch file for Gazebo",id:"ros-2-launch-file-for-gazebo",level:3}];function d(e){const n={code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Understand the structure of the Simulation Description Format (SDF) and its key elements."}),"\n",(0,s.jsx)(n.li,{children:"Model realistic rigid body dynamics, including mass and inertia."}),"\n",(0,s.jsx)(n.li,{children:"Define detailed collision properties and surface friction for realistic interactions."}),"\n",(0,s.jsx)(n.li,{children:"Build a custom Gazebo world with lighting, physics properties, and multiple static and dynamic models."}),"\n",(0,s.jsx)(n.li,{children:"Create a complete ROS 2 package to launch and manage a Gazebo simulation."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SDF (Simulation Description Format)"}),": An XML-based format that describes everything in a simulation, from the robot's physical properties to the environment's lighting. It is the native format for Gazebo."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<link>"})}),": A fundamental building block in SDF, representing a single rigid body of the robot with physical properties."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<inertial>"})}),": An element within a link that defines its dynamic properties: mass and the inertia tensor."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<collision>"})}),': An element that defines the geometry of a link for the purpose of physics calculations. This is what the physics engine "sees."']}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<visual>"})}),": An element that defines the geometry and appearance of a link for rendering. This is what the user sees. It can be simpler or more complex than the collision geometry."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<joint>"})}),": An element that connects two links and defines their relative motion (e.g., ",(0,s.jsx)(n.code,{children:"revolute"})," for a hinge, ",(0,s.jsx)(n.code,{children:"prismatic"})," for a slider)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo Plugins"}),": Shared libraries that can be loaded at runtime to extend the functionality of Gazebo. There are plugins for sensors, actuators, and ROS 2 communication."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"deep-theoretical-explanation",children:"Deep Theoretical Explanation"}),"\n",(0,s.jsxs)(n.h3,{id:"the-collision-and-visual-distinction",children:["The ",(0,s.jsx)(n.code,{children:"<collision>"})," and ",(0,s.jsx)(n.code,{children:"<visual>"})," Distinction"]}),"\n",(0,s.jsx)(n.p,{children:"A crucial concept in simulation is the separation of collision geometry from visual geometry."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<collision>"})}),": This geometry should be as simple as possible (e.g., spheres, cylinders, boxes) while still accurately representing the robot's shape for physics interactions. Complex collision meshes are computationally expensive and can slow down the simulation."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.code,{children:"<visual>"})}),": This geometry can be a highly detailed mesh (e.g., from a CAD model) to provide a photo-realistic appearance without affecting the physics performance."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"By keeping them separate, you can have a simulation that both looks good and runs fast."}),"\n",(0,s.jsx)(n.h3,{id:"modeling-friction",children:"Modeling Friction"}),"\n",(0,s.jsxs)(n.p,{children:["Friction in Gazebo is defined within the ",(0,s.jsx)(n.code,{children:"<surface>"})," element of a ",(0,s.jsx)(n.code,{children:"<collision>"}),' tag. The most common model is the "cone of friction" model, which uses two primary coefficients:']}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"mu"})," (\u03bc)"]}),": The coefficient of static friction. It defines the force required to initiate motion between two surfaces."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsxs)(n.strong,{children:[(0,s.jsx)(n.code,{children:"mu2"})," (\u03bc2)"]}),": The second coefficient of friction, used for anisotropic friction (where friction differs by direction)."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["You can also set parameters like ",(0,s.jsx)(n.code,{children:"slip1"})," and ",(0,s.jsx)(n.code,{children:"slip2"})," to model wheel slippage, which is critical for realistic ground vehicle simulations."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<collision name="collision">\n  <geometry>\n    <box size="0.5 0.5 0.1"/>\n  </geometry>\n  <surface>\n    <friction>\n      <ode>\n        <mu>1.0</mu>\n        <mu2>1.0</mu2>\n      </ode>\n    </friction>\n  </surface>\n</collision>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"practical-tasks",children:"Practical Tasks"}),"\n",(0,s.jsx)(n.h3,{id:"1-create-a-gazebo-package",children:"1. Create a Gazebo Package"}),"\n",(0,s.jsx)(n.p,{children:"Create a dedicated ROS 2 package to hold your simulation files."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws/src\nros2 pkg create my_gazebo_package --build-type ament_python --dependencies rclpy launch_ros\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"2-create-worlds-models-and-launch-directories",children:["2. Create ",(0,s.jsx)(n.code,{children:"worlds"}),", ",(0,s.jsx)(n.code,{children:"models"}),", and ",(0,s.jsx)(n.code,{children:"launch"})," directories"]}),"\n",(0,s.jsx)(n.p,{children:"Inside your new package, create directories to store your world files, robot models, and launch files."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd my_gazebo_package\nmkdir worlds models launch\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-create-the-world-and-robot-sdf-files",children:"3. Create the World and Robot SDF files"}),"\n",(0,s.jsxs)(n.p,{children:["Place the ",(0,s.jsx)(n.code,{children:"my_world.sdf"})," and ",(0,s.jsx)(n.code,{children:"robot.sdf"})," files (from the templates below) into the ",(0,s.jsx)(n.code,{children:"worlds"})," and ",(0,s.jsx)(n.code,{children:"models"})," directories, respectively."]}),"\n",(0,s.jsx)(n.h3,{id:"4-create-the-launch-file",children:"4. Create the Launch File"}),"\n",(0,s.jsxs)(n.p,{children:["Place the ",(0,s.jsx)(n.code,{children:"spawn_robot.launch.py"})," file into the ",(0,s.jsx)(n.code,{children:"launch"})," directory. You will need to modify the ",(0,s.jsx)(n.code,{children:"get_package_share_directory"})," call to use your new package name, ",(0,s.jsx)(n.code,{children:"my_gazebo_package"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"5-build-and-launch",children:"5. Build and Launch"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Build your workspace:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,s.jsxs)(n.li,{children:["Launch the simulation:","\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"ros2 launch my_gazebo_package spawn_robot.launch.py\n"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"diagrams",children:"Diagrams"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SDF File Structure"}),": A tree diagram showing the nested structure of an SDF file, starting from the root ",(0,s.jsx)(n.code,{children:"<sdf>"})," tag, branching to ",(0,s.jsx)(n.code,{children:"<world>"})," and ",(0,s.jsx)(n.code,{children:"<model>"}),", and then further down to ",(0,s.jsx)(n.code,{children:"<link>"}),", ",(0,s.jsx)(n.code,{children:"<joint>"}),", ",(0,s.jsx)(n.code,{children:"<collision>"}),", ",(0,s.jsx)(n.code,{children:"<visual>"}),", and ",(0,s.jsx)(n.code,{children:"<inertial>"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Gazebo-ROS 2 Communication"}),": A diagram illustrating how Gazebo communicates with ROS 2. It shows the ",(0,s.jsx)(n.code,{children:"gazebo_ros"})," plugins (like ",(0,s.jsx)(n.code,{children:"libgazebo_ros_init.so"})," and ",(0,s.jsx)(n.code,{children:"libgazebo_ros_factory.so"}),") acting as a bridge, converting ROS 2 messages into Gazebo API calls and vice-versa."]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"code-templates",children:"Code Templates"}),"\n",(0,s.jsx)(n.h3,{id:"detailed-robot-sdf-with-friction",children:"Detailed Robot SDF with Friction"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- examples/module2/chapter2-gazebo-physics/robot.sdf --\x3e\n<sdf version="1.6">\n  <model name="my_robot">\n    <link name="base_link">\n      <inertial>\n        <mass>1.0</mass>\n        <inertia>\n          <ixx>0.083</ixx>\n          <ixy>0.0</ixy>\n          <ixz>0.0</ixz>\n          <iyy>0.083</iyy>\n          <iyz>0.0</iyz>\n          <izz>0.083</izz>\n        </inertia>\n      </inertial>\n      <collision name="collision">\n        <geometry>\n          <box>\n            <size>0.5 0.5 0.5</size>\n          </box>\n        </geometry>\n        <surface>\n          <friction>\n            <ode>\n              <mu>0.8</mu>\n              <mu2>0.8</mu2>\n            </ode>\n          </friction>\n        </surface>\n      </collision>\n      <visual name="visual">\n        <geometry>\n          <box>\n            <size>0.5 0.5 0.5</size>\n          </box>\n        </geometry>\n      </visual>\n    </link>\n  </model>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"world-sdf-with-custom-physics",children:"World SDF with Custom Physics"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'\x3c!-- examples/module2/chapter2-gazebo-physics/my_world.sdf --\x3e\n<sdf version="1.6">\n  <world name="default">\n    <physics type="ode">\n      <max_step_size>0.001</max_step_size>\n      <real_time_factor>1</real_time_factor>\n      <real_time_update_rate>1000</real_time_update_rate>\n    </physics>\n    <gravity>0 0 -9.81</gravity>\n    <include>\n      <uri>model://sun</uri>\n    </include>\n    <include>\n      <uri>model://ground_plane</uri>\n    </include>\n  </world>\n</sdf>\n'})}),"\n",(0,s.jsx)(n.h3,{id:"ros-2-launch-file-for-gazebo",children:"ROS 2 Launch file for Gazebo"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# examples/module2/chapter2-gazebo-physics/spawn_robot.launch.py\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch import LaunchDescription\nfrom launch.actions import ExecuteProcess\nfrom launch_ros.actions import Node\n\ndef generate_launch_description():\n    pkg_share = get_package_share_directory('my_gazebo_package') # <-- Change to your package name\n    world_file = os.path.join(pkg_share, 'worlds', 'my_world.sdf')\n    robot_file = os.path.join(pkg_share, 'models', 'robot.sdf')\n\n    return LaunchDescription([\n        ExecuteProcess(\n            cmd=['gazebo', '--verbose', world_file, '-s', 'libgazebo_ros_init.so', '-s', 'libgazebo_ros_factory.so'],\n            output='screen'\n        ),\n        Node(\n            package='gazebo_ros',\n            executable='spawn_entity.py',\n            arguments=['-entity', 'my_robot', '-file', robot_file],\n            output='screen'\n        )\n    ])\n"})})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,i)=>{i.d(n,{R:()=>a,x:()=>t});var o=i(6540);const s={},l=o.createContext(s);function a(e){const n=o.useContext(l);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(l.Provider,{value:n},e.children)}}}]);