"use strict";(globalThis.webpackChunkmy_website=globalThis.webpackChunkmy_website||[]).push([[500],{8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>o});var i=s(6540);const t={},r=i.createContext(t);function c(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(r.Provider,{value:n},e.children)}},9341:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>c,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"module1/chapter3","title":"ROS 2 Services and Actions: Request/Reply and Long-Running Tasks","description":"Learning Objectives","source":"@site/docs/module1/chapter3.md","sourceDirName":"module1","slug":"/module1/chapter3","permalink":"/Physical-AI-Robotic-Book/ur/docs/module1/chapter3","draft":false,"unlisted":false,"editUrl":"https://github.com/DaniyalAneeq/Physical-AI-Robotic-Book/tree/main/AIdd-book/docs/module1/chapter3.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"id":"chapter3","title":"ROS 2 Services and Actions: Request/Reply and Long-Running Tasks","sidebar_position":3},"sidebar":"bookSidebar","previous":{"title":"ROS 2 Nodes, Topics, and Messages","permalink":"/Physical-AI-Robotic-Book/ur/docs/module1/chapter2"},"next":{"title":"Parameters and TF2: Configuration and Coordinate Frames","permalink":"/Physical-AI-Robotic-Book/ur/docs/module1/chapter4"}}');var t=s(4848),r=s(8453);const c={id:"chapter3",title:"ROS 2 Services and Actions: Request/Reply and Long-Running Tasks",sidebar_position:3},o=void 0,l={},a=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Key Concepts",id:"key-concepts",level:2},{value:"Deep Theoretical Explanation",id:"deep-theoretical-explanation",level:2},{value:"Services vs. Actions: Choosing the Right Tool",id:"services-vs-actions-choosing-the-right-tool",level:3},{value:"Anatomy of a ROS 2 Action",id:"anatomy-of-a-ros-2-action",level:3},{value:"Practical Tasks",id:"practical-tasks",level:2},{value:"1. Define a Custom Service",id:"1-define-a-custom-service",level:3},{value:"2. Define a Custom Action",id:"2-define-a-custom-action",level:3},{value:"3. Build and Implement",id:"3-build-and-implement",level:3},{value:"Diagrams",id:"diagrams",level:2},{value:"Code Templates",id:"code-templates",level:2},{value:"Python <code>rclpy</code> Service Server",id:"python-rclpy-service-server",level:3},{value:"Python <code>rclpy</code> Action Server",id:"python-rclpy-action-server",level:3}];function d(e){const n={code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Understand the synchronous request/reply communication pattern of ROS 2 Services and when to use it."}),"\n",(0,t.jsx)(n.li,{children:"Define custom service types and implement Service Servers and Clients in Python."}),"\n",(0,t.jsx)(n.li,{children:"Understand the asynchronous, goal-based communication pattern of ROS 2 Actions and its advantages for long-running tasks."}),"\n",(0,t.jsx)(n.li,{children:"Define custom action types and implement Action Servers and Clients in Python."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"key-concepts",children:"Key Concepts"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Services"}),": A strictly synchronous, one-to-one communication pattern. When a client calls a service, it ",(0,t.jsx)(n.strong,{children:"blocks"})," (waits) until the server completes the request and returns a single response. This is ideal for quick, atomic operations like querying a sensor value or retrieving a configuration parameter."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Actions"}),": An asynchronous communication pattern designed for long-running, goal-oriented tasks that may take a significant amount of time to complete. Unlike services, actions are non-blocking. They provide continuous feedback on their progress and are cancellable. This is perfect for tasks like navigation, manipulation, or complex computations."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Service Definition (",(0,t.jsx)(n.code,{children:".srv"})," file)"]}),": A file that defines the structure of a service's request and response. The request and response sections are separated by a ",(0,t.jsx)(n.code,{children:"---"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Action Definition (",(0,t.jsx)(n.code,{children:".action"})," file)"]}),": A file that defines the structure for an action. It is composed of three parts, separated by ",(0,t.jsx)(n.code,{children:"---"}),":","\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal"}),": The request sent by the client to initiate the action."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result"}),": The final outcome sent by the server upon completion."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback"}),": Intermediate updates sent by the server while the goal is being executed."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"deep-theoretical-explanation",children:"Deep Theoretical Explanation"}),"\n",(0,t.jsx)(n.h3,{id:"services-vs-actions-choosing-the-right-tool",children:"Services vs. Actions: Choosing the Right Tool"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Feature"}),(0,t.jsx)(n.th,{children:"Services"}),(0,t.jsx)(n.th,{children:"Actions"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Paradigm"})}),(0,t.jsx)(n.td,{children:"Synchronous Request/Response"}),(0,t.jsx)(n.td,{children:"Asynchronous Goal/Feedback/Result"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Execution"})}),(0,t.jsx)(n.td,{children:"Blocking (Client waits for response)"}),(0,t.jsx)(n.td,{children:"Non-blocking (Client can perform other tasks)"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Feedback"})}),(0,t.jsx)(n.td,{children:"None"}),(0,t.jsx)(n.td,{children:"Continuous feedback during execution"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.strong,{children:"Preemption"})}),(0,t.jsx)(n.td,{children:"No (Cannot be cancelled)"}),(0,t.jsx)(n.td,{children:"Yes (Client can request to cancel the goal)"})]})]})]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Use Case"}),"    | Quick, atomic queries or commands      | Long-running, stateful tasks (navigation, manipulation)         |"]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"anatomy-of-a-ros-2-action",children:"Anatomy of a ROS 2 Action"}),"\n",(0,t.jsx)(n.p,{children:"An action is more complex than a service and involves several components on both the client and server side."}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Action Server"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal Callback"}),": A function that is called when a new goal is received from a client. The server can choose to ",(0,t.jsx)(n.code,{children:"ACCEPT"})," or ",(0,t.jsx)(n.code,{children:"REJECT"})," the goal."]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handle Accepted Callback"}),": This callback is triggered after a goal has been accepted. It's where you typically start the execution of the action, often by spawning a new thread to avoid blocking the main ROS event loop."]}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Execute Callback"}),": The main function where the long-running task is performed. It should periodically check if a cancellation has been requested and publish feedback."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Cancel Callback"}),": A function that is called when a client requests to cancel the current goal. The server can ",(0,t.jsx)(n.code,{children:"ACCEPT"})," or ",(0,t.jsx)(n.code,{children:"REJECT"})," the cancellation request."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Action Client"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Send Goal"}),": The client initiates the action by sending a goal message to the server. This is an asynchronous call."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Goal Response Callback"}),": This function is called when the server accepts or rejects the goal."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Feedback Callback"}),": This function is called whenever the server publishes feedback for the action."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Result Callback"}),": This function is called when the action completes and the server sends the final result."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"practical-tasks",children:"Practical Tasks"}),"\n",(0,t.jsxs)(n.p,{children:["These tasks should be performed within the ",(0,t.jsx)(n.code,{children:"my_first_package"})," you created in the previous chapter."]}),"\n",(0,t.jsx)(n.h3,{id:"1-define-a-custom-service",children:"1. Define a Custom Service"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create a ",(0,t.jsx)(n.code,{children:"srv"})," directory: ",(0,t.jsx)(n.code,{children:"mkdir -p ~/ros2_ws/src/my_first_package/my_first_package/srv"})]}),"\n",(0,t.jsxs)(n.li,{children:["Create the file ",(0,t.jsx)(n.code,{children:"AddTwoInts.srv"})," inside the ",(0,t.jsx)(n.code,{children:"srv"})," directory:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# ~/ros2_ws/src/my_first_package/my_first_package/srv/AddTwoInts.srv\nint64 a\nint64 b\n---\nint64 sum\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Update ",(0,t.jsx)(n.code,{children:"package.xml"})," and ",(0,t.jsx)(n.code,{children:"setup.py"})," as you did for custom messages to ensure the service definition is found and built."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"2-define-a-custom-action",children:"2. Define a Custom Action"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["Create an ",(0,t.jsx)(n.code,{children:"action"})," directory: ",(0,t.jsx)(n.code,{children:"mkdir -p ~/ros2_ws/src/my_first_package/my_first_package/action"})]}),"\n",(0,t.jsxs)(n.li,{children:["Create the file ",(0,t.jsx)(n.code,{children:"Fibonacci.action"})," inside the ",(0,t.jsx)(n.code,{children:"action"})," directory:","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# ~/ros2_ws/src/my_first_package/my_first_package/action/Fibonacci.action\nint32 order\n---\nint32[] sequence\n---\nint32[] partial_sequence\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["Update ",(0,t.jsx)(n.code,{children:"package.xml"})," and ",(0,t.jsx)(n.code,{children:"setup.py"})," to include the new action definition."]}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"3-build-and-implement",children:"3. Build and Implement"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build the definitions"}),":","\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"cd ~/ros2_ws\ncolcon build\nsource install/setup.bash\n"})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Implement the Server/Client Nodes"}),": Create the Python files for the service server/client and action server/client within ",(0,t.jsx)(n.code,{children:"my_first_package/my_first_package/"}),". Use the code from the templates below, but be sure to import your newly defined custom types (e.g., ",(0,t.jsx)(n.code,{children:"from my_first_package.srv import AddTwoInts"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsxs)(n.strong,{children:["Update ",(0,t.jsx)(n.code,{children:"setup.py"})]}),": Add the new nodes to the ",(0,t.jsx)(n.code,{children:"entry_points"})," in your ",(0,t.jsx)(n.code,{children:"setup.py"})," file."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Build and Run"}),": Build the workspace again and run your new service and action nodes. Use ",(0,t.jsx)(n.code,{children:"ros2 service call"})," and ",(0,t.jsx)(n.code,{children:"ros2 action send_goal"})," to test them from the command line."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"diagrams",children:"Diagrams"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Service Communication Flow"}),": A sequence diagram showing the ",(0,t.jsx)(n.code,{children:"AddTwoIntsClient"})," sending a request message to the ",(0,t.jsx)(n.code,{children:"AddTwoIntsServer"}),'. The client\'s timeline shows a "blocked" state until the server processes the request and sends back a response message.']}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Action State Machine"}),": A state diagram illustrating the lifecycle of an action goal. It will show the primary states (PENDING, ACTIVE, SUCCEEDED, CANCELED, ABORTED) and the transitions between them, triggered by events like ",(0,t.jsx)(n.code,{children:"goal_request"}),", ",(0,t.jsx)(n.code,{children:"accept_goal"}),", ",(0,t.jsx)(n.code,{children:"execute"}),", ",(0,t.jsx)(n.code,{children:"publish_feedback"}),", ",(0,t.jsx)(n.code,{children:"finish"}),", and ",(0,t.jsx)(n.code,{children:"cancel_request"}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"code-templates",children:"Code Templates"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["(Note: These templates use ",(0,t.jsx)(n.code,{children:"example_interfaces"})," for simplicity. You should replace them with your custom-defined ",(0,t.jsx)(n.code,{children:"my_first_package"})," interfaces after creating them.)"]})}),"\n",(0,t.jsxs)(n.h3,{id:"python-rclpy-service-server",children:["Python ",(0,t.jsx)(n.code,{children:"rclpy"})," Service Server"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# examples/module1/chapter3-services-actions/add_two_ints_server.py\nimport rclpy\nfrom rclpy.node import Node\nfrom example_interfaces.srv import AddTwoInts\n\nclass AddTwoIntsService(Node):\n    def __init__(self):\n        super().__init__('add_two_ints_server')\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\n        self.get_logger().info('Add Two Ints Service Server started.')\n\n    def add_two_ints_callback(self, request, response):\n        response.sum = request.a + request.b\n        self.get_logger().info(f'Incoming request: a={request.a}, b={request.b}')\n        self.get_logger().info(f'Sending response: {response.sum}')\n        return response\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = AddTwoIntsService()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsxs)(n.h3,{id:"python-rclpy-action-server",children:["Python ",(0,t.jsx)(n.code,{children:"rclpy"})," Action Server"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"# examples/module1/chapter3-services-actions/fibonacci_action_server.py\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer\nfrom example_interfaces.action import Fibonacci\nimport time\n\nclass FibonacciActionServer(Node):\n    def __init__(self):\n        super().__init__('fibonacci_action_server')\n        self._action_server = ActionServer(\n            self,\n            Fibonacci,\n            'fibonacci',\n            self.execute_callback)\n        self.get_logger().info('Fibonacci Action Server started.')\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n        feedback_msg = Fibonacci.Feedback()\n        feedback_msg.partial_sequence = [0, 1]\n\n        for i in range(1, goal_handle.request.order):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                self.get_logger().info('Goal canceled')\n                return Fibonacci.Result()\n\n            feedback_msg.partial_sequence.append(feedback_msg.partial_sequence[i] + feedback_msg.partial_sequence[i-1])\n            self.get_logger().info(f'Feedback: {feedback_msg.partial_sequence}')\n            goal_handle.publish_feedback(feedback_msg)\n            time.sleep(1)\n\n        goal_handle.succeeded()\n        result = Fibonacci.Result()\n        result.sequence = feedback_msg.partial_sequence\n        return result\n\ndef main(args=None):\n    rclpy.init(args=args)\n    node = FibonacciActionServer()\n    rclpy.spin(node)\n    rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsxs)(n.em,{children:["(Client code templates omitted for brevity but would follow a similar pattern of replacing ",(0,t.jsx)(n.code,{children:"example_interfaces"})," with the custom package interfaces.)"]})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}}}]);